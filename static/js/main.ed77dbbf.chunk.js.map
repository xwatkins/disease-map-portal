{"version":3,"sources":["MinervaMap.js","useData.js","ProteinCard.js","UniProtList.js","App.js","serviceWorker.js","index.js"],"names":["MinervaMap","mapRef","useRef","useEffect","createMap","elementId","serverUrl","projectId","submapId","className","id","ref","useDataApi","url","useState","data","setData","a","async","axios","get","headers","Accept","result","console","error","getData","ProteinCard","showWholeFunction","setShowWholeFunction","diseaseNotes","diseases","title","gene","proteinName","href","accession","target","key","proteinId","description","length","substring","onClick","geneCoordinates","map","coordinate","start","chromosome","end","ensemblGeneId","ensemblTranscriptId","ensemblTranslationId","note","diseaseName","UniProtList","Object","keys","App","setAccession","window","addEventListener","e","reference","detail","references","find","type","resource","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ed77dbbf.chunk.js","sourcesContent":["import React, { useEffect, useRef } from \"react\";\nimport \"./MinervaMap.css\";\n\nconst serverUrl = \"https://pdmap.uni.lu/minerva/\";\nconst projectId = \"pd_map_autumn_19\";\nconst submapId = 4895;\n\nconst MinervaMap = () => {\n  const mapRef = useRef(null);\n  useEffect(() => {\n    if (mapRef !== null) {\n      let elementId = \"map\";\n      // eslint-disable-next-line no-undef\n      createMap({ elementId, serverUrl, projectId, submapId });\n    }\n  }, []);\n\n  return (\n    <div className=\"App-column\">\n      <div id=\"map\" className=\"map\" ref={mapRef}></div>\n    </div>\n  );\n};\n\nexport default MinervaMap;\n","import { useState, useEffect } from \"react\";\nimport axios from \"axios\";\n\nconst useDataApi = url => {\n  const [data, setData] = useState({});\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const result = await axios.get(url, {\n          headers: {\n            Accept: \"application/json\"\n          }\n        });\n        setData(result.data);\n      } catch (e) {\n        console.error(e);\n      }\n    };\n    getData();\n  }, [url]);\n\n  return data;\n};\n\nexport default useDataApi;\n","import React, { Fragment, useState } from \"react\";\nimport { Card } from \"franklin-sites\";\n\nconst ProteinCard = ({ data, id = \"\" }) => {\n  const [showWholeFunction, setShowWholeFunction] = useState(false);\n\n  const diseaseNotes = data.diseases;\n\n  return (\n    <Card\n      title={\n        <Fragment>\n          {data.gene} - {data.proteinName}{\" \"}\n          <small>\n            <a\n              href={`//www.uniprot.org/uniprot/${data.accession}`}\n              target=\"_blank\"\n            >\n              {data.accession}\n            </a>\n          </small>\n        </Fragment>\n      }\n      key={data.proteinId}\n    >\n      <h4>Function</h4>\n      <p>\n        {!showWholeFunction && data.description.length > 200 ? (\n          <Fragment>\n            <span>{data.description.substring(0, 197)}... </span>\n            <a onClick={() => setShowWholeFunction(true)}>more</a>\n          </Fragment>\n        ) : (\n          data.description\n        )}\n      </p>\n      {data.geneCoordinates && (\n        <div>\n          <h4>Gene information</h4>\n          {data.geneCoordinates.map(coordinate => (\n            <p key={coordinate.start}>\n              {coordinate.chromosome}:{coordinate.start}-{coordinate.end}{\" \"}\n              <a\n                href={`//www.ensembl.org/id/${coordinate.ensemblGeneId}`}\n                target=\"_blank\"\n              >\n                {coordinate.ensemblGeneId}\n              </a>{\" \"}\n              <a\n                href={`//www.ensembl.org/id/${coordinate.ensemblTranscriptId}`}\n                target=\"_blank\"\n              >\n                {coordinate.ensemblTranscriptId}\n              </a>{\" \"}\n              <a\n                href={`//www.ensembl.org/id/${coordinate.ensemblTranslationId}`}\n                target=\"_blank\"\n              >\n                {coordinate.ensemblTranslationId}\n              </a>\n            </p>\n          ))}\n        </div>\n      )}\n      {diseaseNotes && (\n        <Fragment>\n          {diseaseNotes.length > 0 && <h4>Disease notes</h4>}\n          {diseaseNotes.map(note => (\n            <Fragment key={note.diseaseName}>\n              <h5>{note.diseaseName}</h5>\n              <p>{note.note}</p>\n            </Fragment>\n          ))}\n        </Fragment>\n      )}\n    </Card>\n  );\n};\n\nexport default ProteinCard;\n","import React from \"react\";\nimport useDataApi from \"./useData\";\nimport ProteinCard from \"./ProteinCard\";\n\nconst baseUrl = \"//wwwdev.ebi.ac.uk/uniprot/api/diseaseservice/proteins/\";\nconst apiURL = `//wwwdev.ebi.ac.uk/uniprot/api/uniprotkb/accession/`;\n\nconst UniProtList = ({ accession }) => {\n  const data = useDataApi(`${baseUrl}${accession}`);\n\n  if (!data || Object.keys(data).length <= 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"App-column\">\n      <ProteinCard data={data.result} />\n    </div>\n  );\n};\n\nexport default UniProtList;\n","import React, { useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport MinervaMap from \"./MinervaMap\";\nimport UniProtList from \"./UniProtList\";\n\nfunction App() {\n  const [accession, setAccession] = useState();\n\n  useEffect(() => {\n    window.addEventListener(\"map-click\", e => {\n      const reference = e.detail[0].references.find(\n        ref => ref.type === \"UNIPROT\"\n      );\n      if (!reference) {\n        return;\n      }\n      setAccession(reference.resource);\n    });\n  }, []);\n\n  return (\n    <div className=\"App\">\n      {accession && <UniProtList accession={accession} />}\n      <MinervaMap />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}